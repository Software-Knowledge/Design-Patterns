封装算法
---
1. 我们需要进一步地深入学习封装算法。

<!-- TOC -->

- [1. 引入](#1-引入)
  - [1.1. 例子:泡一杯茶和泡一杯咖啡](#11-例子泡一杯茶和泡一杯咖啡)
    - [1.1.1. 抽象prepareRecipe()](#111-抽象preparerecipe)
    - [1.1.2. 回顾:我们在过去干了什么](#112-回顾我们在过去干了什么)
- [2. 模板方法模式](#2-模板方法模式)
  - [2.1. 定义模板方法模式](#21-定义模板方法模式)
  - [2.2. 一个神奇的东西:hook(挂钩)](#22-一个神奇的东西hook挂钩)
  - [2.3. 使用钩子](#23-使用钩子)
    - [2.3.1. 例子](#231-例子)
    - [2.3.2. 什么时候使用钩子](#232-什么时候使用钩子)
    - [2.3.3. 钩子的用处](#233-钩子的用处)
    - [2.3.4. 钩子的优越性](#234-钩子的优越性)
- [3. 设计模式:好莱坞原则](#3-设计模式好莱坞原则)
  - [3.1. 好莱坞原则与依赖倒置原则之间的区别](#31-好莱坞原则与依赖倒置原则之间的区别)
- [4. java API中的模板方法](#4-java-api中的模板方法)
  - [4.1. 排序非数字的部分:](#41-排序非数字的部分)
  - [4.2. 其他的API的方法:](#42-其他的api的方法)
  - [4.3. Applet](#43-applet)
- [5. 模板方法和策略模式的不同](#5-模板方法和策略模式的不同)

<!-- /TOC -->

# 1. 引入

## 1.1. 例子:泡一杯茶和泡一杯咖啡
1. 将每一个步骤分离开，就会取得比较好的效果。
2. 类图设计

![](img\fz/fz-1.png)

3. 在类的实际过程中我们可以将部分公有的方法抽象到超类。
4. 接下来，我们来思考一下:我们是否也可以将相应的更加具体的方法抽象出来。

### 1.1.1. 抽象prepareRecipe()
1. 首先将两个方法进行抽象。
    + 将相关的方法进行格式化，首先格式化名称。
2. 将部分接口下放到具体实现的部分。

![](img\fz/fz-2.png)

### 1.1.2. 回顾:我们在过去干了什么
1. 我们首先将茶和咖啡进行抽象泛化得到咖啡因饮料
2. 接下来我们在相应的子类中讲不同的部分进行实例化。

![](img\fz/fz-3.png)

# 2. 模板方法模式

![](img\fz/fz-4.png)

1. 模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
2. 那么我们把刚刚的prepareRecipe()的处理情况来简单的看一下。

## 2.1. 定义模板方法模式
1. **模板方法**模式在一个方法中定义一个算法的骨架，而接下来将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
2. 这个模式更多的是用来创建一个算法的模板。

![](img\fz/fz-5.png)

## 2.2. 一个神奇的东西:hook(挂钩)
1. 在一个模板类中，我们可以有一个具体的但是什么事情都不做的挂钩方法:`void hook(){}`
2. 那么模板中的hook方法有什么作用呢？
    + 钩子是一种被声明在抽象类中的方法，但是只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩。是否挂钩由子类决定。
    + 通常来说是缺省的实现。
    + 可以一般是`return true;`

![](img\fz/fz-6.png)

## 2.3. 使用钩子

### 2.3.1. 例子
1. 如果我们想要完成对于一个饮料是否调价调料，我们可以通过钩子来控制相应的算法指令
2. 我们覆盖了`public boolean customerWantsCondiments()`这个钩子来实现相应的方法。

### 2.3.2. 什么时候使用钩子
1. 当我们的子类必须提供算法中某个方法或步骤的实现的时，我们选择使用抽象方法。
    + 特别是这个算法的部分是可选的时候。

### 2.3.3. 钩子的用处
1. 第一种作用:钩子可以让子类实现算法中可选的部分，或者在钩子对于子类的实现并不重要的时候，子类可以对钩子置之不理。
2. 钩子的另一个用法是让子类有能力对模板方法中某些即将发生的(或者刚刚发生的)步骤做出反应。

### 2.3.4. 钩子的优越性
1. 在写模板方法的时候，我们要平衡抽象方法和钩子方法的比例，通过折中的方法来保证子类负担不太大，并且充分具有弹性。
2. 不要将算法切分的过细。

# 3. 设计模式:好莱坞原则
1. 模式内容:别调用我们，我们会调用你。
2. 原则的用处:
    1. 可以给我们一种防止“依赖腐败”的方法。
    2. 在高层和底层组件之间相互依赖的时候，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。

## 3.1. 好莱坞原则与依赖倒置原则之间的区别
1. 依赖倒置原则要求我们尽量避免使用具体类，而多使用抽象
2. 好莱坞原则是用在创建框架或组件上的一种技巧，让底层组件能够被钩进计算中，而保证高层组件依赖低层组件。
3. 低层组件一定不可以调用高层组件中的方法吗？
    + 并不是的，低层组件在结束时，常常会调用从超类继承来的方法，我们要做的是，避免让高层和低层组件之间又明显的**环状依赖**。

# 4. java API中的模板方法
1. 我们只需要调用相应的API中的模块式方法即可。

![](img\fz/fz-7.png)

## 4.1. 排序非数字的部分:
1. 我们需要将compareTo()这个方法进行实现，否则不能进行排序
    + 实现鸭子的排序,我们要在Duck这个类中实现`public int compareTo(Object object)`

![](img\fz/fz-8.png)

## 4.2. 其他的API的方法:
    1. read(byte b[],int off,int len)的模板方法是read()
    2. swing的窗口程序:其中的paint()方法。在默认状态中，paint()是不做事情的，但是我们可以这样子插入我们自己的代码

![](img\fz/fz-9.png)

## 4.3. Applet
1. applet是一个能够在网页上执行的小程序，其中Applet类中提供了很多的钩子。

![](img\fz/fz-10.png)

# 5. 模板方法和策略模式的不同
1. 模板方法是定义一个算法的大纲，而由其子类定义其中某些步骤的内容。
2. 策略则是主要通过对象组合的方式让客户可以选择算法实现。
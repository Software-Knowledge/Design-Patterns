里氏替换原则
---

# 里氏替换原则
1. 子类应当可以替换父类并出现在父类能够出现的地方。
2. 比如：公司搞年度派对，都有员工都可以抽奖，那么不管是新员工还是老员工，也不管是总部员工还是外派员工，都应当可以参加抽奖。
3. 里氏替换至少包含以下两个含义：
   1. 里氏替换原则是针对**继承**而言的，如果**继承**是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。
   2. 如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。 

# 实例
```java
public class Program
{
    private static void Main(string[] args)
    {
        A a = new A();
        System.out.println(a.func1(100, 50));
        B b = new B();
        System.out.println(b.func1(100, 50));
        System.out.println(b.func2(100, 50));
    }
}

public class A
{
    public int func1(int num1, int num2)
    {
        return num1 - num2;
    }
}

public class B extends A
{
    public int func1(int num1, int num2)
    {
        return num1 + num2;
    }

    public int func2(int num1, int num2)
    {
        return func1(num1, num2) + 100;
    }
}
```

1. 由上述代码可以看出，若类B在继承类A时不注意，重写了父类方法func1就会导致结果与预想的不一致，改变了父类原有的功能。故里氏转换原则应满足以下要求：
   1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
   2. 子类可以增加自己特有的方法
   3. 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
   4. 当子类的方法实现父类的抽象方法时，方法的返回值应比父类更严格
2. 优点：
   1. 可以大大减少程序的bug以及增强代码的可读性
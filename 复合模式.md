复合模式
---
1. java使用OO设计可以使用多个设计模式，也就是说是复合模式

<!-- TOC -->

- [1. 引入](#1-引入)
  - [1.1. 实例:重新拥抱鸭子](#11-实例重新拥抱鸭子)
    - [1.1.1. 使用观察者模式](#111-使用观察者模式)
    - [1.1.2. 一些其他的疑问](#112-一些其他的疑问)
  - [1.2. 安全性和透明性](#12-安全性和透明性)
- [2. 复合模式之王:MVC模式](#2-复合模式之王mvc模式)
  - [2.1. 模型(Model)](#21-模型model)
  - [2.2. 控制器(Controller)](#22-控制器controller)
  - [2.3. 视图(View)](#23-视图view)
  - [2.4. 各部分之间的关系(包括客户)](#24-各部分之间的关系包括客户)
  - [2.5. 其他注解](#25-其他注解)
  - [2.6. 组成MVC的都有什么模式？](#26-组成mvc的都有什么模式)
    - [2.6.1. 策略模式](#261-策略模式)
    - [2.6.2. 观察者模式](#262-观察者模式)
    - [2.6.3. 组合模式](#263-组合模式)
  - [2.7. Java DJ View](#27-java-dj-view)
    - [2.7.1. 创建碎片](#271-创建碎片)
  - [2.8. 适配模型:将心跳显示同样适用在这个节奏模型中。](#28-适配模型将心跳显示同样适用在这个节奏模型中)
  - [2.9. MVC与Web](#29-mvc与web)
    - [2.9.1. 修正:做相应的适配](#291-修正做相应的适配)
- [3. 设置Servlet环境](#3-设置servlet环境)

<!-- /TOC -->

# 1. 引入
1. 复合模式是一种由模式所构成的模式，换句话说就是各种模式相互组合。
2. 在一个解决方案中结合两个或多个模式已解决一般或重复发生的问题。

## 1.1. 实例:重新拥抱鸭子
1. 首先创建一个Quackable接口
2. 之后一些鸭子实现了Quackable接口
3. 创建一个确认鸭子能叫的模拟器simulate
4. 设计一个Goose(鹅)类，可是怎么用保证Goose可以实现Quackable类。
5. 使用鹅适配器保证模拟器也可以使用鹅
6. 我们需要知道一类对象叫的次数，在相应的类中装饰对象来获得被装饰过的行为。
7. 我们需要用工厂来生产鸭子，工厂也要扩展子相应的抽象工厂。

![](img\fh/fh-1.png)

8. 设置模拟器来使用这个工厂，我们相应的创建一个多态的方法。
    + simulate传入的是一个抽象工厂
9. 问题:我们不想管理个别的鸭子，我们更想管理一组鸭子。
    + 使用组合模式，使用ArrayList()来管理一组鸭子。
    + 使用组合模式，来完成每个鸭子的迭代。
10. 观察一个鸭子:使用观察者模式
    + 使用Observerable接口

### 1.1.1. 使用观察者模式
1. 我们需要在每一个类中实现注册和通知，但是我们这次要在另一个被称作Observable的类中封装注册和通知的代码。然后和QuackOberverable结合在一起。

![](img\fh/fh-2.png)
![](img\fh/fh-3.png)

### 1.1.2. 一些其他的疑问
1. 以上这个例子只是各种组合的结合，而并不是完全的复合模式。

## 1.2. 安全性和透明性
1. 我们知道为一个Duck添加某些东西是无意义的，但是这样的设计比较安全。

# 2. 复合模式之王:MVC模式
1. MVC模式(Model-View-Controller)
2. 简单的过程:你的操作传给控制器，控制器操纵模型，模型告诉视图状态已经更新，视图为你更新，

## 2.1. 模型(Model)
1. 模型持有所有的数据、状态和程序逻辑，模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者。

## 2.2. 控制器(Controller)
1. 取得用户的输入并解读其对模型的意思。
2. 控制器为视图实现行为，它聪明地将来自视图的动作转成模型上的动作。
3. 并不负责实现应用逻辑等，通常情况下一个视图有一个控制器。

## 2.3. 视图(View)
1. 用来呈现模型，视图通常从模型中取得它需要显示的状态与数据

## 2.4. 各部分之间的关系(包括客户)
1. 作为用户，主要是和视图进行交互。
2. 控制器要求模型改变状态
3. 控制器要求视图发生改变
4. 当模型状态改变时，模型会通知视图进行刷新。
5. 视图向模型询问状态。

## 2.5. 其他注解
1. 控制器可以变成模型的观察者吗？
    + 可以的，控制器会想模型注册、模型一有改变就通知控制器。当模型直接影响到用户界面的时候，就会这么制作，充分保证及时进行更新。
2. 控制器会做什么？
    1. 控制器会解读输入，并且通过输入操纵模型。
    2. 为何不把这部分放在视图层?一是因为这会让视图的代码变得更加复杂。二是因为这会曹成模型和视图之间紧耦合。

## 2.6. 组成MVC的都有什么模式？

### 2.6.1. 策略模式
1. 视图和控制器.
2. 视图是一个对象，可以调整使用不同的策略，而控制器提供了策略。视图只关心系统中可视的部分，对于任何界面行为，都委托给控制器处理。

### 2.6.2. 观察者模式
1. 模型实现了观察者模式，当状态改变时，相关对象将持续更新。使用观察者模式，可以让模型完全独立于视图和控制器。同一个模型可以使用不同视图或者多个视图。

### 2.6.3. 组合模式
1. 每个显示组件如果不是组合节点，就是叶节点。

## 2.7. Java DJ View
1. 利用MVC来看完成这件事情。

![](img\fh/fh-4.png)

### 2.7.1. 创建碎片
1. 一部分一部分按顺序，逐渐实现三大组件。

## 2.8. 适配模型:将心跳显示同样适用在这个节奏模型中。
1. 我们使用适配器模式是最好地能够适配这个问题的模型。

## 2.9. MVC与Web
1. Web开发也都在适配MVC，保证它能够充分符合浏览器/服务器模型。我们称这样的适配器为"Model 2"

![](img\fh/fh-5.png)

2. 工作流程
    1. 利用网页服务器，发出HTTP请求，牵扯到表单数据的传送，被servlet接受后，开始接受解析数据。
    2. servlet扮演控制器，通常向模型(一般是数据库发出请求，处理结果往往是通过JavaBean进行打包。
    3. 控制器将控制权交给视图:视图是JSP，唯一工作就是来产生页面以及相应动态控件。
    4. 视图通过HTTP将页面返回浏览器
3. Model 2充分地确定保证了各部分人的分工。并且是MVC模式在Web上的实现。

### 2.9.1. 修正:做相应的适配
1. 步骤一:模型，直接进行套用即可
2. 步骤二:控制器Servlet
![](img\fh/fh-6.png)
3. 步骤三:创建视图


# 3. 设置Servlet环境
1. Tomcat的网页是挺好的。
2. 另一本《Head First Servlets & JSP》可以作为参考。

![](img\fh/fh-7.png)